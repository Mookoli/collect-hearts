<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Herzli sammle</title>
  <style>
    :root {
      --bg: #fff7fb;
      --ink: #222;
      --accent: #ff4d91;
    }

    html,
    body {
      height: 100%;
      margin: 0
    }

    body {
      background: var(--bg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: var(--ink)
    }

    #wrap {
      position: relative;
      height: 100%;
      overflow: hidden
    }

    canvas {
      position: absolute;
      inset: 0;
      display: block;
      width: 100%;
      height: 100%
    }

    .hud {
      position: absolute;
      top: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      pointer-events: none;
      flex-wrap: wrap
    }

    .hud .rowWrap {
      display: flex;
      gap: 12px;
      align-items: center;
      pointer-events: auto
    }

    .hideOnMobile {
      display: block
    }

    .showOnMobile {
      display: none
    }

    .badge {
      pointer-events: auto;
      background: #ffffffdd;
      backdrop-filter: blur(4px);
      border: 1px solid #0001;
      padding: 8px 12px;
      border-radius: 999px;
      box-shadow: 0 6px 20px #00000014;
      display: inline-flex;
      gap: 10px;
      align-items: center
    }

    .btn {
      pointer-events: auto;
      border: 0;
      background: var(--accent);
      color: #fff;
      padding: 8px 14px;
      border-radius: 999px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 8px 24px #ff4d9133
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: radial-gradient(1200px 600px at 50% -10%, #ffffffcc, #fff7fb 55%, #ffd6e9 100%)
    }

    .card {
      width: min(520px, 92vw);
      background: #fff;
      border-radius: 24px;
      padding: 22px;
      box-shadow: 0 20px 60px #0000001a;
      border: 1px solid #0002
    }

    .card h1 {
      margin: 0 0 8px;
      font-size: clamp(22px, 3.2vw, 34px)
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
      margin-top: 10px;
      justify-content: center;
    }

    .charGroup {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: center;
      /* center the heads */
      width: 100%;
    }

    #startChars .charBtn {
      width: 64px;
      height: 64px;
    }

    #startChars .charBtn img {
      border-radius: 999px;
    }

    .charBtn {
      border: 1px solid #0002;
      background: #fff;
      padding: 0;
      width: 40px;
      height: 40px;
      border-radius: 999px;
      display: grid;
      place-items: center;
      cursor: pointer;
      box-shadow: 0 4px 10px #00000012
    }

    .charBtn img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 999px
    }

    .charBtn:focus {
      outline: 2px solid #0005;
      outline-offset: 2px
    }

    .charBtn.selected {
      outline: 3px solid var(--accent);
      outline-offset: 2px;
      box-shadow: 0 0 0 4px #ff4d9122
    }

    .end {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.55)
    }

    .end .card {
      text-align: center;
      width: min(360px, 88vw);
      padding: 16px;
      border-radius: 18px
    }

    .thumbHint {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      opacity: .8;
      background: #000;
      color: #fff;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      display: none
    }

    @media(hover:none) and (pointer:coarse) {
      .thumbHint {
        display: block
      }
    }

    /* Mobile-friendly layout: move character picker to bottom bar */
    @media (max-width: 640px) {
      .hideOnMobile {
        display: none
      }

      .showOnMobile {
        display: block
      }

      .hud {
        top: 8px;
        gap: 8px
      }

      .badge {
        padding: 6px 10px
      }

      .btn {
        padding: 6px 12px
      }
    }

    @keyframes oneTurn {
      to {
        transform: rotate(1turn);
      }
    }

    .charBtn img.spin {
      animation: oneTurn 500ms linear;
    }

    .endChar {
      width: 72px;
      height: 72px;
      border: none;
      margin: 6px auto 10px;
      display: block;
      opacity: 0;
      transition: opacity .3s ease;
      border-radius: 0;
      object-fit: contain;
      border: none;
      background-color: transparent;
      mix-blend-mode: multiply;
      filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.15));
    }

    .end .revealLater {
      opacity: 0;
      transform: translateY(6px);
      transition: opacity .25s ease, transform .25s ease;
    }

    .end.showDetails .revealLater {
      opacity: 1;
      transform: none;
    }

    .endChar {
      transform-origin: 50% 85%;
    }

    /* exaggerated triple bounce with spin */
    .endChar {
      transform-origin: 50% 85%;
    }

    @keyframes tripleBounce {
      0% {
        transform: scale(0.7, 1.3);
      }

      /* crouch */
      10% {
        transform: scale(1.3, 0.8);
      }

      /* first pop */
      25% {
        transform: scale(0.85, 1.15);
      }

      /* rebound */
      40% {
        transform: scale(1.2, 0.85);
      }

      /* second pop */
      55% {
        transform: scale(0.9, 1.1);
      }

      /* rebound */
      70% {
        transform: scale(1.1, 0.9);
      }

      /* third pop */
      85% {
        transform: scale(0.96, 1.04);
      }

      /* settle */
      100% {
        transform: scale(1, 1);
      }

      /* rest */
    }

    .end.showDetails .endChar {
      animation: tripleBounce 1.2s cubic-bezier(.25, .8, .25, 1);
      opacity: 1;
    }

    #startBtn {
      margin-top: 20px;
      /* more space below heads */
      min-width: 90px;
      /* slightly wider */
      border-radius: 999px;
      padding: 10px 24px;
      font-size: 16px;
      box-shadow: 0 8px 20px #ff4d9133;
    }

    .bottomBar {
      position: absolute;
      left: 12px;
      right: 12px;
      bottom: 12px;
      display: flex;
      justify-content: center;
      pointer-events: none;
    }

    .bottomBar .badge {
      pointer-events: auto;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }

    /* slightly larger touch targets on small screens */
    @media (max-width: 640px) {
      #bottomChars .charBtn {
        width: 56px;
        height: 56px;
      }
    }
  </style>
</head>

<body>
  <div id="wrap">
    <canvas id="game"></canvas>

    <div class="hud">
      <div class="badge" id="scoreBadge"><strong id="score">0</strong> ðŸ’–</div>
      <div class="badge"><strong id="timer">30</strong>s</div>
    </div>

    <div id="bottomBar" class="bottomBar">
      <div class="badge" style="gap:10px">
        <div class="charGroup" id="bottomChars" aria-label="Choose character">
          <button class="charBtn selected" data-char="bride">
            <img src="bride.png" alt="" />
          </button>
          <button class="charBtn" data-char="groom">
            <img src="groom.png" alt="" />
          </button>
          <button class="charBtn" data-char="kid">
            <img src="kid.png" alt="" />
          </button>
        </div>
        <button class="btn" id="restartBtn" title="Restart (R)">Nomal!</button>
      </div>
    </div>

    <div class="overlay" id="startOverlay">
      <div class="card">
        <h1></h1>
        <p style="margin:6px 0 0; opacity:.8"></p>
        <div class="row" style="margin-top:16px">
          <!-- Clickable heads on start screen -->
          <div class="charGroup" id="startChars" aria-label="Choose character to start">
            <button class="charBtn selected" data-char="bride" title="Bride">
              <img src="bride.png" alt="" />
            </button>
            <button class="charBtn" data-char="groom" title="Groom">
              <img src="groom.png" alt="" />
            </button>
            <button class="charBtn" data-char="kid" title="Kid">
              <img src="kid.png" alt="" />
            </button>
          </div>
        </div>
        <div class="row">
          <button id="startBtn" class="btn">Start</button>
        </div>
      </div>
    </div>
    <div class="end" id="endOverlay">
      <div class="card">
        <img id="endChar" class="endChar" alt="" />
        <p class="revealLater"><strong><span id="finalScore">0</span></strong> ðŸ’–</p>
        <div class="row revealLater" style="justify-content:center">
          <button id="againBtn" class="btn">Nomal!</button>
        </div>
      </div>
    </div>
  </div>


  <script>
    const TARGET_FPS = 30;            // cap FPS
    const FRAME_MS = 1000 / TARGET_FPS;
    const MAX_HEARTS = 100;            // cap objects on screen (â†‘ more hearts)
    const HEART_LIFETIME = 40000;     // ms before a heart despawns
    const SPAWN_EVERY_MS = 300;       // spawn interval in ms (â†“ = more frequent)
    const DPR = 1;                    // force 1x to reduce fill rate
    const SQUASH_INTENSITY = 0.18;   // how bouncy the scaling feels (0.1â€“0.25 nice)
    const MAX_SQUASH = 0.28;         // hard cap for stretch amount

    // ---------- Canvas ----------
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: true });

    let width = 0, height = 0;
    function resize() {
      const rect = canvas.getBoundingClientRect();
      width = Math.floor(rect.width * DPR);
      height = Math.floor(rect.height * DPR);
      canvas.width = width; canvas.height = height;
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    }
    window.addEventListener('resize', resize);
    resize();

    const bottomChars = document.getElementById('bottomChars');


    // ---------- UI refs ----------
    const scoreEl = document.getElementById('score');
    const timerEl = document.getElementById('timer');
    const finalScoreEl = document.getElementById('finalScore');
    const startOverlay = document.getElementById('startOverlay');
    const endOverlay = document.getElementById('endOverlay');
    const startBtn = document.getElementById('startBtn');
    const againBtn = document.getElementById('againBtn');
    const restartBtn = document.getElementById('restartBtn');
    const startChars = document.getElementById('startChars');
    const hudChars = document.getElementById('hudChars');

    // ---------- Image loading ----------
    const images = { bride: new Image(), groom: new Image(), kid: new Image(), heart: new Image() };
    images.bride.src = 'bride.png';
    images.groom.src = 'groom.png';
    images.kid.src = 'kid.png';
    images.heart.src = 'heart.png'; // optional; falls back to emoji if missing

    const loaded = new Set();
    Object.entries(images).forEach(([k, img]) => {
      img.onload = () => loaded.add(k);
      img.onerror = () => console.warn(`${k}.png not found; using fallback if possible`);
    });

    function imgOrFallback(kind) {
      if (kind === 'heart') return loaded.has('heart') ? images.heart : null;
      return loaded.has(kind) ? images[kind] : null;
    }

    // ---------- Character selection helpers ----------
    let currentCharKey = 'bride';
    function setCharacter(key) {
      currentCharKey = key;
      // Update selected state in both pickers
      for (const group of [startChars, bottomChars]) {
        if (!group) continue;
        group.querySelectorAll('.charBtn').forEach(btn => {
          btn.classList.toggle('selected', btn.dataset.char === key);
        });
        const chosen = group.querySelector(`.charBtn[data-char="${key}"] img`);
        if (chosen) {
          // restart animation even if class was there before
          chosen.classList.remove('spin');
          // force reflow to restart CSS animation
          void chosen.offsetWidth;
          chosen.classList.add('spin');
          chosen.addEventListener('animationend', () => {
            chosen.classList.remove('spin');
          }, { once: true });
        }
      }
    }

    function wirePicker(group) {
      group.addEventListener('click', (e) => {
        const btn = e.target.closest('.charBtn');
        if (!btn) return;
        const key = btn.dataset.char;
        setCharacter(key);
      });
      // keyboard support
      group.querySelectorAll('.charBtn').forEach(btn => {
        btn.setAttribute('tabindex', '0');
        btn.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); btn.click(); }
        });
      });
    }

    wirePicker(startChars);
    if (bottomChars) wirePicker(bottomChars);

    // ---------- Draw helpers ----------
    function drawHeart(x, y) {
      const hs = imgOrFallback('heart');
      if (hs) { ctx.drawImage(hs, (x | 0) - 20, (y | 0) - 20, 40, 40); }
      else {
        ctx.save(); ctx.font = '32px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('ðŸ’–', x | 0, y | 0); ctx.restore();
      }
    }

    function currentPlayerImage() { return imgOrFallback(currentCharKey); }
    function drawPlayer(x, y) {
      const img = currentPlayerImage();
      // compute stretch based on speed
      const speedPx = Math.hypot(player.vx, player.vy);
      const stretch = Math.min(MAX_SQUASH, speedPx * SQUASH_INTENSITY);
      const sx = 1 - stretch * 0.6;   // thinner sideways
      const sy = 1 + stretch;         // taller when moving
      const ang = speedPx > 0.0001 ? Math.atan2(player.vy, player.vx) : 0;

      // soft shadow under the head
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.ellipse((x | 0), ((y | 0) + 26), 18 * (1 + stretch * 0.5), 6 * (1 - stretch * 0.3), 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      ctx.save();
      ctx.translate(x | 0, y | 0);
      if (ang) ctx.rotate(ang);
      ctx.scale(sx, sy);
      if (img) {
        ctx.drawImage(img, -24, -24, 48, 48);
      } else {
        ctx.fillStyle = '#ffd6e9';
        ctx.beginPath(); ctx.arc(0, 0, 24, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#ff4d91';
        ctx.font = '14px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('ðŸ™‚', 0, 0);
      }
      ctx.restore();
    }


    // ---------- Game state ----------
    const hearts = []; // {x,y,born}
    const player = { x: 200, y: 200, tx: 200, ty: 200, speed: 0.35, vx: 0, vy: 0 };
    let score = 0;
    let timeLeft = 30; // seconds
    let running = false;

    function setTarget(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      player.tx = clientX - rect.left;
      player.ty = clientY - rect.top;
    }
    window.addEventListener('mousemove', e => setTarget(e.clientX, e.clientY));
    window.addEventListener('touchmove', e => { if (e.touches[0]) setTarget(e.touches[0].clientX, e.touches[0].clientY); }, { passive: true });

    // Spawn logic
    let lastSpawn = 0;
    function spawnHeart(now) {
      if (hearts.length >= MAX_HEARTS) return;
      const margin = 24;
      const x = margin + Math.random() * (canvas.clientWidth - margin * 2);
      const y = margin + Math.random() * (canvas.clientHeight - margin * 2);
      hearts.push({ x, y, born: now });
    }

    function reset() {
      score = 0; scoreEl.textContent = '0';
      timeLeft = 30; timerEl.textContent = '30';
      hearts.length = 0; lastSpawn = 0;

      const rect = canvas.getBoundingClientRect();
      // place player at center-ish and clear velocity
      player.x = player.tx = rect.width * 0.5;
      player.y = player.ty = rect.height * 0.7;
      player.vx = 0;
      player.vy = 0;
    }


    function start() {
      // ensure character is whatever is selected on the start screen
      const startSelected = startChars.querySelector('.charBtn.selected');
      if (startSelected) setCharacter(startSelected.dataset.char);
      reset();
      startOverlay.style.display = 'none';
      endOverlay.style.display = 'none';
      running = true;
      lastTime = performance.now();
      accTime = 0;
      requestAnimationFrame(loop);
    }

    function finish() {
      running = false;
      finalScoreEl.textContent = String(score);
      const endCharEl = document.getElementById('endChar');
      if (endCharEl) endCharEl.src = `${currentCharKey}.png`;
      endOverlay.style.display = 'flex';
      endOverlay.classList.add('showDetails'); // instantly show all details and trigger bounce
    }


    // UI wiring
    restartBtn.addEventListener('click', start);
    startBtn.addEventListener('click', start);
    againBtn.addEventListener('click', start);
    window.addEventListener('keydown', (e) => { if (e.key.toLowerCase() === 'r') start(); });

    // Main loop (FPS cap)
    let lastTime = performance.now();
    let accTime = 0;
    function loop(now) {
      if (!running) return;
      const dtMs = now - lastTime; lastTime = now; accTime += dtMs;
      update(dtMs, now);
      if (accTime >= FRAME_MS) { render(); accTime = 0; }
      requestAnimationFrame(loop);
    }

    function update(dtMs, now) {
      const dt = Math.min(0.05, dtMs / 1000);
      const lerp = Math.min(1, player.speed * dt * 60);

      const prevX = player.x, prevY = player.y;   // <â€” add
      player.x += (player.tx - player.x) * lerp;
      player.y += (player.ty - player.y) * lerp;
      player.vx = player.x - prevX;               // <â€” add
      player.vy = player.y - prevY;               // <â€” add

      if (now - lastSpawn > SPAWN_EVERY_MS) { spawnHeart(now); lastSpawn = now; }

      for (let i = hearts.length - 1; i >= 0; i--) {
        const h = hearts[i];
        if (now - h.born > HEART_LIFETIME) { hearts.splice(i, 1); continue; }
        const dx = player.x - h.x, dy = player.y - h.y;
        if (dx * dx + dy * dy < 24 * 24) { score++; scoreEl.textContent = String(score); hearts.splice(i, 1); }
      }

      timeLeft -= dt;
      if (timeLeft <= 0) { timerEl.textContent = '0'; finish(); } else {
        timerEl.textContent = String(Math.ceil(timeLeft));
      }
    }

    function render() {
      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
      for (let i = 0; i < hearts.length; i++) drawHeart(hearts[i].x, hearts[i].y);
      drawPlayer(player.x, player.y);
    }

    // Initialize selection state
    setCharacter('bride');
  </script>
</body>

</html>